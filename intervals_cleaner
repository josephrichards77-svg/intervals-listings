# intervals_cleaning.py

import re
import html


def looks_all_caps(s: str) -> bool:
    """Return True if alphabetic characters are overwhelmingly uppercase."""
    letters = [c for c in s if c.isalpha()]
    if not letters:
        return False
    uppers = sum(1 for c in letters if c.isupper())
    return uppers / len(letters) >= 0.80


def soft_titlecase(s: str) -> str:
    """Title-case but preserve words like 'III', 'I', 'II', etc."""
    parts = s.split()
    out = []
    for w in parts:
        if w.isupper() and len(w) <= 3:  # preserve acronyms/roman nums
            out.append(w)
        else:
            out.append(w.capitalize())
    return " ".join(out)


# ============================================================
# CLEANER — safe, preserves ’71, fixes ALL-CAPS
# ============================================================

def clean(text):
    """General cleaner: strip matched quote pairs, collapse spaces, fix ALL-CAPS."""
    if text is None:
        return ""

    s = str(text)
    s = html.unescape(s).strip()

    # Only strip quotes when matching pairs
    matched_pairs = [
        ('"', '"'),
        ("'", "'"),
        ("“", "”"),
        ("‘", "’"),
    ]
    for left, right in matched_pairs:
        if s.startswith(left) and s.endswith(right):
            s = s[len(left):-len(right)].strip()
            break

    # Fix ALL-CAPS titles → normal Title Case
    if looks_all_caps(s):
        s = soft_titlecase(s)

    # Collapse double spaces
    s = re.sub(r"\s{2,}", " ", s)

    return s


# ============================================================
# NORMALISER — ensure all fields exist and are strings
# ============================================================

def normalise_row(row):

    normal = {
        "venue": "",
        "date": "",
        "title": "",
        "director": "",
        "runtime_min": "",
        "format": "",
        "times": [],
        "year": "",
        "extra": "",
        "url": "",
    }

    for key in normal:
        if key not in row:
            continue

        val = row[key]

        if key == "times":
            if isinstance(val, list):
                normal[key] = [clean(t) for t in val if t]
            else:
                t = clean(str(val)) if val is not None else ""
                normal[key] = [t] if t else []
        else:
            normal[key] = clean(str(val)) if val is not None else ""

    return normal


# ============================================================
# MERGER
# ============================================================

def merge_rows(existing, new):
    key = (new["venue"], new["date"], new["title"])

    for row in existing:
        if (row["venue"], row["date"], row["title"]) == key:

            # merge times
            for t in new["times"]:
                if t not in row["times"]:
                    row["times"].append(t)

            # fill missing fields
            for field in ["format", "extra", "url", "director", "runtime_min", "year"]:
                if not row[field] and new[field]:
                    row[field] = new[field]

            return

    existing.append(new)


# ============================================================
# EXPORT — 9 fixed columns
# ============================================================

def export_rows(rows):

    rows_sorted = sorted(rows, key=lambda r: (r["date"], r["title"]))

    lines = []
    for r in rows_sorted:
        date     = r["date"] or ""
        venue    = r["venue"] or ""
        title    = r["title"] or ""
        director = r["director"] or ""
        runtime  = str(r["runtime_min"] or "")
        fmt      = r["format"] or ""
        times    = ", ".join(sorted(r["times"])) if r["times"] else ""
        year     = r["year"] or ""
        notes    = r["extra"] or ""

        line = ";".join([
            date,
            venue,
            title,
            director,
            runtime,
            fmt,
            times,
            year,
            notes,
        ])
        lines.append(line)

    return "\n".join(lines)
